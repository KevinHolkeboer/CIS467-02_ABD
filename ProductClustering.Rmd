---
title: "ProductClustering.Rmd"
author: "Zack Poorman, Justin Houstin"
date: "12/6/2020"
output: html_document
---

```{r}
library(tidyverse)
library(tidymodels)
db <- readxl::read_xlsx("combined_data.xlsx", sheet = "Product")
```

```{r}
rec <- 
  recipe(formula = ~ FrontlinePrice + BeverageType + Package, data = db) %>% 
  step_range(all_numeric()) %>% 
  step_dummy(all_nominal(), one_hot=T) %>%
  prep()
normalized <- juice(rec)

library(dbscan)
if(!require(devtools)) install.packages("devtools")
devtools::install_github("kassambara/factoextra")
library(factoextra)
library(naivebayes)

set.seed(123)
f <- dbscan::dbscan(normalized, 1.35, 5)
normalized$CLUSTER=f$cluster
normalized$CLUSTER <- as.factor(normalized$CLUSTER)
db$Cluster=normalized$CLUSTER
ind <- sample(2, nrow(normalized), replace = T, prob = c(0.8, 0.2))

train <- normalized[ind == 1,]
test <- normalized[ind == 2,]
model <- naive_bayes(CLUSTER ~ ., data = train)

# Confusion Matrix - train data
p1 <- predict(model, train)
tab1 <- table(p1, train$CLUSTER)
1 - sum(diag(tab1)) / sum(tab1)

# Confusion Matrix - test data
p2 <- predict(model, test)
tab2 <- table(p2, test$CLUSTER)
1 - sum(diag(tab2)) / sum(tab2)

newPrice <- 750
newBevType <- "IMPORT BEER"
newSize <- "1 GALL (4)"

# Compare product data to clusters and find nearest cluster. 
newPrice <- (newPrice-min(db$FrontlinePrice))/(max(db$FrontlinePrice)-min(db$FrontlinePrice))

newBevType <- str_replace_all(newBevType, " ", ".")
newBevType <- paste("BeverageType_", newBevType, sep="")

newSize <- str_replace_all(newSize, " ", ".")
newSize <- str_replace_all(newSize, "/", ".")
newSize <- str_replace_all(newSize, "\\(", ".")
newSize <- str_replace_all(newSize, "\\)", ".")
newSize <- paste("Package_X", newSize, sep="")

newProduct <- vector(mode="numeric", length=ncol(normalized))

newProduct[match("FrontlinePrice", names(normalized))] <- newPrice
newProduct[match(newBevType, names(normalized))] <- 1
newProduct[match(newSize, names(normalized))] <- 1

newProduct <- as.data.frame(t(newProduct))
colnames(newProduct) <- colnames(normalized[,1:ncol(normalized)-1])

clusterPredict <- predict(model, newProduct)

# Get which customers sell the beverages in this cluster

inCluster <- subset(db, Cluster == clusterPredict)
itemList <- inCluster[['ItemKey']]

Customer_Product <- readxl::read_xlsx("combined_data.xlsx", sheet = "Customer-Product")

i = 1
custList <- vector()
for(ID in itemList) {
  temp <- subset(Customer_Product, ItemKey == itemList[i])
  custList <- c(custList, temp["CusKey"])
  i = i + 1
}

custList <- unlist(custList, recursive = FALSE)
custList <- unname(custList)
custList <- unique(custList)

# Get table of customers that sold these items.

isFirst = TRUE
for (ID in itemList) {
  if (isFirst) {
    items <- subset(Customer_Product, ItemKey == ID)
    isFirst = FALSE
  }
  else {
    temp <- subset(Customer_Product, ItemKey == ID)
    items <- rbind(items, temp)
  }
}

isFirst = TRUE
for (ID in custList) {
  if (isFirst) {
    itemSellers <- subset(items, CusKey == ID)
    isFirst = FALSE
  }
  else {
    temp <- subset(items, CusKey == ID)
    itemSellers <- rbind(itemSellers, temp)
  }
}

# For each customer, sum the Net Revenue of these beverages

custList <- itemSellers[['CusKey']]
custList <- unique(custList)

custProfit <- vector()
for (ID in custList) {
  temp <- subset(itemSellers, CusKey == ID)
  custProfit <- c(custProfit, sum(temp$NetRevenue))
}

customers <- readxl::read_xlsx("combined_data.xlsx", sheet = "Customer")

isFirst = TRUE
for (ID in custList) {
  if (isFirst) {
    newPrediction <- subset(customers, CusKey == ID)
    isFirst = FALSE
  }
  else {
    temp <- subset(customers, CusKey == ID)
    newPrediction <- rbind(newPrediction, temp)
  }
}

newPrediction $NetRevenue <- custProfit

# Order by NetRevenue and get top 10%

newPrediction  <- newPrediction [order(-newPrediction $NetRevenue),]

top10Percent = ceiling(nrow(newPrediction ) * 0.10)

newPrediction  <- head(newPrediction , top10Percent)

```